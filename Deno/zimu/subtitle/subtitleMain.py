#coding:utf-8import datetimeimport osimport PIL.ImageOpsimport cv2import pytesseractfrom PIL import Image, ImageFilter, ImageEnhancefrom imageOptimization import imgTransferdef two(img):  # img：图片地址    i = 0    # img = Image.open('/home/yang/png/0.png') # 读入图片    img = img.convert("RGBA")    while i < 4:  # 循环次数视情况进行调整        i = i + 1        pixdata = img.load()        # 一次二值化        for y in range(img.size[1]):            for x in range(img.size[0]):                if pixdata[x, y][0] < 90:  # 使RGB值中R小于90的像素点变成纯黑                    pixdata[x, y] = (0, 0, 0, 255)        for y in range(img.size[1]):            for x in range(img.size[0]):                if pixdata[x, y][1] < 190:  # 使RGB值中G小于90的像素点变成纯黑                    pixdata[x, y] = (0, 0, 0, 255)        for y in range(img.size[1]):            for x in range(img.size[0]):                if pixdata[x, y][2] > 0:  # 使RGB值中B大于0的像素点变成纯白                    pixdata[x, y] = (255, 255, 255, 255)    # 理论上的二值化代码只有上面那些，RGB值的调整阈值需要针对不同验证码反复调整。同时实际中一组阈值往往没法做到完美，后面的部分是视实际情况添加的类似部分    # 二次二值化（除去某些R、G、B值接近255的颜色）    for y in range(img.size[1]):        for x in range(img.size[0]):            if pixdata[x, y][0] < 254:                pixdata[x, y] = (0, 0, 0, 255)        for y in range(img.size[1]):            for x in range(img.size[0]):                if pixdata[x, y][1] < 254:                    pixdata[x, y] = (0, 0, 0, 255)        for y in range(img.size[1]):            for x in range(img.size[0]):                if pixdata[x, y][2] > 0:                    pixdata[x, y] = (255, 255, 255, 255)    # 三次二值化，怼掉纯黄色（实际使用中发现很多图片最后剩几个纯黄色的像素点）    for y in range(img.size[1]):        for x in range(img.size[0]):            if pixdata[x, y] == (255, 255, 0, 255):                pixdata[x, y] = (0, 0, 0, 255)    # img.show()    return img# 去除噪点def clear_noise(img):  # img：图片地址    white = (255, 255, 255, 255)    black = (0, 0, 0, 255)    # img = Image.open('/home/yang/png/0.png') # 读入图片    pixdata = img.load()    X = img.size[0] - 1  # 因为我校的验证码二值化后正好剩下一圈宽度为一像素的白边，所以这么处理了    Y = img.size[1] - 1    def icolor(RGBA):        if RGBA == white:            return (1)        else:            return (0)    for y in range(Y):        for x in range(X):            if (x < 1 or y < 1):                pass            else:                if icolor(pixdata[x, y]) == 1:                    pass                else:                    if (                            icolor(pixdata[x + 1, y]) +                            icolor(pixdata[x, y + 1]) +                            icolor(pixdata[x - 1, y]) +                            icolor(pixdata[x, y - 1]) +                            icolor(pixdata[x - 1, y - 1]) +                            icolor(pixdata[x + 1, y - 1]) +                            icolor(pixdata[x - 1, y + 1]) +                            icolor(pixdata[x + 1, y + 1])                    ) > 6:                        # 如果一个黑色像素周围的8个像素中白色像素数量大于5个，则判断其为噪点，填充为白色                        pixdata[x, y] = white                        # 填充白点    for y in range(Y):        for x in range(X):            if (x < 1 or y < 1):                pass            else:                if icolor(pixdata[x, y]) == 0:                    pass                else:                    if (                            (icolor(pixdata[x + 1, y])) +                            (icolor(pixdata[x, y + 1])) +                            (icolor(pixdata[x - 1, y])) +                            (icolor(pixdata[x, y - 1]))                    ) < 2:                        # 如果一个白色像素上下左右4个像素中黑色像素的个数大于2个，则判定其为有效像素，填充为黑色。                        pixdata[x, y] = black    # 二次去除黑点    for y in range(Y):        for x in range(X):            if (x < 1 or y < 1):                pass            else:                if icolor(pixdata[x, y]) == 1:                    pass                else:                    if (                            icolor(pixdata[x + 1, y]) +                            icolor(pixdata[x, y + 1]) +                            icolor(pixdata[x - 1, y]) +                            icolor(pixdata[x, y - 1])                    ) > 2:                        pixdata[x, y] = white    # img.show()    return imgdef del_noise(im):    #   去除边框的黑色    data = im.getdata()    w, h = im.size    black_point = 0    for x in range(1, w - 1):        for y in range(1, h - 1):            if x > 245 or y > 245:                im.putpixel((x - 1, y - 1), (0, 0, 0))            if x > w - 3 or y > h - 3:                im.putpixel((x + 1, y + 1), (0, 0, 0))    # im.show()    print('图像降噪完成')    # image.save('xxxx.jpg')    return im#  图片增强 图片二值化函数:符合阈值之上,设为1;否则设为0# PIL二值图算法:# 手动遍历像素，以一定阈值为界限，把图片变成二值图像。def binarizing(img, threshold):  # input: gray image    # 加权平均值法    """传入image对象进行灰度、二值处理"""    # img = img.convert("L")  # 转灰度    # 灰度图像的每个像素点色值在0-255,0代表纯黑，255代表纯白，其实二值化的原理通俗说就是我们对灰度二维码图像做浅灰色统一设置为白色（255），深灰色统一设置为黑色（0）    #    # threshold = 140    # table = []    # for i in range(256):    #     if i < threshold:    #         table.append(0)    #     else:    #         table.append(1)    # out = img.point(table, '1')    # img = img.point(lambda x: 255 if x > threshold else 0)    pixdata = img.load()    w, h = img.size    # 【二值化】    #     根据阈值 standard , 将所有像素都置为 0(黑色) 或 255(白色), 便于接下来的分割    # 遍历所有像素，大于阈值的为黑色    for x in range(w):        for y in range(h):            # print(pixdata[x, y])            if pixdata[x, y] > threshold:                pixdata[x, y] = 255            else:                pixdata[x, y] = 0    # img = img.point(lambda x: 255 if x > threshold else 0)    return img# 图片去噪  对于像素值>245的邻域像素，判别为属于背景色  如果一个像素上下左右4各像素值有超过2个 对于像素值>245的邻域像素，判别为属于背景色# 邻域像素算法:# 对于像素值>245的邻域像素，判别为属于背景色，如果一个像素上下左右4各像素值有超过2个像素属于背景色，那么该像素就是噪声。def denoising(img):  # input: gray image    pixdata = img.load()    w, h = img.size    for y in range(1, h - 1):        for x in range(1, w - 1):            count = 0            if pixdata[x, y - 1] > 245:  # 上                count = count + 1            if pixdata[x, y + 1] > 245:  # 下                count = count + 1            if pixdata[x - 1, y] > 245:  # 左                count = count + 1            if pixdata[x + 1, y] > 245:  # 右                count = count + 1            if pixdata[x - 1, y - 1] > 245:  # 左上                count = count + 1            if pixdata[x - 1, y + 1] > 245:  # 左下                count = count + 1            if pixdata[x + 1, y - 1] > 245:  # 右上                count = count + 1            if pixdata[x + 1, y + 1] > 245:  # 右下                count = count + 1            if count > 4:                pixdata[x, y] = 255    return imgdef readImageToTxt(ex_folder, imageFilePath, tempTime):    config = ('--oem 1 --psm 3')    out = imgTransfer(ex_folder + imageFilePath)    # text = pytesseract.image_to_string(Image.open(ex_folder + imageFilePath), lang="chi_sim+eng", config=config)    text = pytesseract.image_to_string(out, lang="chi_sim+eng", config=config)    # 删除一些异常符号    exclude_char_list = '\ .:|\'\"[]()~@#$%^&*_+-={};<>/¥'    text1 = ''.join([x for x in text if x not in exclude_char_list])    text1 = text1.replace("\n", "  ")    print('文件名' + ex_folder + imageFilePath + '   时间：' + tempTime + '----->' + text1)    # I.close()    return text1def format_time(frame_index, fps):    # hours = second // 3600    # minutes = (second - hours * 3600) // 60    # second = second - hours * 3600 - minutes * 60    # microsecond = second.microseconds // 1000    # t = datetime.time(hour=hours, minute=minutes, second=second,microsecond=microsecond)    # return datetime.time.isoformat(t)    td = datetime.timedelta(seconds=frame_index / fps)    ms = td.microseconds // 1000    m, s = divmod(td.seconds, 60)    h, m = divmod(m, 60)    return '{:02d}:{:02d}:{:02d},{:03d}'.format(h, m, s, ms)def cal_stderr(img, imgo=None):    if imgo is None:        return (img ** 2).sum() / img.size * 100    else:        return ((img - imgo) ** 2).sum() / img.size * 100def save_image(ex_folder, img: Image, starts: int, ends: int):    # 保存字幕图片到文件夹    start_time = format_time(starts)    end_time = format_time(ends)    timeline = '-'.join([start_time, end_time]) + ".png"    try:        imgname = os.path.join(ex_folder, timeline)        img.save(imgname)        print('export subtitle at %s' % timeline)    except Exception:        print('export subtitle at %s error' % timeline)def export_subtitle(video_filename, interval=10):    # 申明没张图片图片的临时数据    listTime = []    listContent = []    ex_folder = os.path.splitext(video_filename)[0]    if not os.path.exists(ex_folder):        os.mkdir(ex_folder)    skip_frames = 1    videoCap = cv2.VideoCapture(video_filename)    if videoCap.isOpened():        success = True    else:        success = False        print("读取失败!")    for i in range(skip_frames):        videoCap.read()    # 帧频    fps = videoCap.get(cv2.CAP_PROP_FPS)    interval = fps    # 视频总帧数    total_frames = int(videoCap.get(cv2.CAP_PROP_FRAME_COUNT))    # 图像尺寸    image_size = (int(videoCap.get(cv2.CAP_PROP_FRAME_HEIGHT)), int(videoCap.get(cv2.CAP_PROP_FRAME_WIDTH)))    frame_height = image_size[0]    frame_width = image_size[1]    print("帧频{},视频总帧数{},图像尺寸{}", fps, total_frames, image_size)    curr_frame = 0    # curr_frame = 500    # for j in range(500):    #     videoCap.read()    while success:        success, frame = videoCap.read()        # print("---> 正在读取第%d帧:" % curr_frame, success)        curr_frame += 1        if frame is None:            print('video: %s finish at %d frame.' % (video_filename, curr_frame))            break        # if curr_frame % 500 == 0:        #     print("为了测试强制测试。。。")        #     break        if curr_frame % interval == 0 and success:  # 如路径下有多个视频文件时视频最后一帧报错因此条件语句中加and success INTER_CUBIC THRESH_BINARY INTER_AREA            # // 确定字幕的范围，注意不同的视频文件剪切的索引值不同            # img = frame[int(frame_height * 0.75):frame_height, :]            # img = frame[0:frame_height, :]            # img = img[:, :, 0]            # 需对图像做二值化处理。由于字幕的白色的，像素值为 255，将二值化阈值设为 220            # thresh = 220            # resize_frame = cv2.resize(resize_frame, (frame_width, frame_height*0.2), interpolation=cv2.INTER_AREA)            # # THRESH_BINARY  INTER_AREA            # _, resize_frame = cv2.threshold(img, thresh, 255, cv2.THRESH_BINARY)            # resize_frame = cv2.resize(img, (frame_width, int(frame_height * 0.25)), interpolation=cv2.INTER_AREA)            resize_frame = cv2.resize(frame, (frame_width, frame_height), interpolation=cv2.INTER_AREA)            # resize_frame = cv2.fastNlMeansDenoising(resize_frame)            if cal_stderr(resize_frame) < 1:                continue            # img = Image.fromarray(resize_frame)            # img.show()            tempTime = str(format_time(curr_frame, fps))            cv2.imwrite(ex_folder + "/%s.jpg" % str(curr_frame), resize_frame)            # img.save(ex_folder + "/%s.jpg" % str(curr_frame))            tempContent = readImageToTxt(ex_folder, "/%s.jpg" % str(curr_frame), tempTime)            if (tempContent is not None) and (tempContent.strip() != ''):                listTime.append(tempTime)                listContent.append(tempContent)    print('video: %s export subtitle finish!' % video_filename)    print('数据读取完毕。。。。。。。。。。。。。。。。')    print(listTime)    print(listContent)    # 删除生成的临时图片    removeFileInDir(os.path.splitext(video_filename)[0])    return getAllContent(listContent, listTime)# 删除某目录下特定文件def removeFileInDir(sourceDir):    for file in os.listdir(sourceDir):        file = os.path.join(sourceDir, file)  # 必须拼接完整文件名        if os.path.isfile(file) and file.find(".jpg") > 0:            os.remove(file)            print(file + " remove succeeded")# 清除重复数据def getAllContent(listContent, listTime):    newlistTime = []    newlistContent = []    for i in range(len(listContent)):        print("---------")        if listContent[i - 1] != listContent[i]:            print(listContent[i])            print(listTime[i])            newlistTime.append(listTime[i])            newlistContent.append(listContent[i])            # 记录当前数据    return newlistTime, newlistContentdef saveTxtFile(contentsAtrr, vedioPath):    txtFile = vedioPath + '/subtitle.txt'    if os.path.exists(txtFile):        os.remove(txtFile)    file_handle = open(txtFile, mode='w')    for i in range(len(contentsAtrr[0])):        file_handle.write(contentsAtrr[0][i] + ' \n')        file_handle.write(contentsAtrr[1][i] + ' \n')# @async_calldef subtitleStart(video_filename):    pytesseract.pytesseract.tesseract_cmd = '/usr/local/bin/tesseract'    # video_filename = sys.argv[1]    # video_filename = '/Users/wangbiao/Downloads/Video/video1.mp4'    # 数据读取    contentsAtrr = export_subtitle(video_filename)    print("最后的数据是==========")    print(contentsAtrr[0])    print("==========")    print(contentsAtrr[1])    saveTxtFile(contentsAtrr, os.path.splitext(video_filename)[0])if __name__ == '__main__':    print("程序启动中")    # video_filename = sys.argv[1]    # subtitleStart("/Users/wangbiao/Downloads/Video/视频内容分析.mp4")    subtitleStart("/Users/wangbiao/Downloads/demo/video/视频内容分析.mp4")    # subtitleStart(video_filename)    print("程序异步运行中")