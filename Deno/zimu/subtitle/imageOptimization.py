#coding:utf-8import PIL.ImageOpsimport cv2from PIL import Image, ImageFilter, ImageEnhance#  图片增强 图片二值化函数:符合阈值之上,设为1;否则设为0# PIL二值图算法:# 手动遍历像素，以一定阈值为界限，把图片变成二值图像。def binarizing(img, threshold):  # input: gray image    # 加权平均值法    """传入image对象进行灰度、二值处理"""    # img = img.convert("L")  # 转灰度    # 灰度图像的每个像素点色值在0-255,0代表纯黑，255代表纯白，其实二值化的原理通俗说就是我们对灰度二维码图像做浅灰色统一设置为白色（255），深灰色统一设置为黑色（0）    #    # threshold = 140    # table = []    # for i in range(256):    #     if i < threshold:    #         table.append(0)    #     else:    #         table.append(1)    # out = img.point(table, '1')    # img = img.point(lambda x: 255 if x > threshold else 0)    pixdata = img.load()    w, h = img.size    # 【二值化】    #     根据阈值 standard , 将所有像素都置为 0(黑色) 或 255(白色), 便于接下来的分割    # 遍历所有像素，大于阈值的为黑色    for x in range(w):        for y in range(h):            # print(pixdata[x, y])            if pixdata[x, y] > threshold:                pixdata[x, y] = 255            else:                pixdata[x, y] = 0    # img = img.point(lambda x: 255 if x > threshold else 0)    return img# 图片去噪  对于像素值>245的邻域像素，判别为属于背景色  如果一个像素上下左右4各像素值有超过2个 对于像素值>245的邻域像素，判别为属于背景色# 邻域像素算法:# 对于像素值>245的邻域像素，判别为属于背景色，如果一个像素上下左右4各像素值有超过2个像素属于背景色，那么该像素就是噪声。def denoising(img):  # input: gray image    pixdata = img.load()    w, h = img.size    for y in range(1, h - 1):        for x in range(1, w - 1):            count = 0            if pixdata[x, y - 1] > 245:  # 上                count = count + 1            if pixdata[x, y + 1] > 245:  # 下                count = count + 1            if pixdata[x - 1, y] > 245:  # 左                count = count + 1            if pixdata[x + 1, y] > 245:  # 右                count = count + 1            if pixdata[x - 1, y - 1] > 245:  # 左上                count = count + 1            if pixdata[x - 1, y + 1] > 245:  # 左下                count = count + 1            if pixdata[x + 1, y - 1] > 245:  # 右上                count = count + 1            if pixdata[x + 1, y + 1] > 245:  # 右下                count = count + 1            if count > 4:                pixdata[x, y] = 255    return img# 图片转换:打开图片,滤波器,增强,灰度图转换,去噪,二值化def imgTransfer(f_name):    im = Image.open(f_name)  # 打开图片    im = im.filter(ImageFilter.MedianFilter(1))  # 对于输入图像的每个像素点，该滤波器从（size，size）的区域中拷贝中值对应的像素值存储到输出图像中    # enhance()的参数factor决定着图像的对比度情况。从0.1到0.5，再到0.8，2.0，图像的对比度依次增大.0.0为纯灰色图像;1.0为保持原始    im = ImageEnhance.Contrast(im).enhance(2.2)    im = im.convert('L')  # 灰度图转换    # im.show()    # im = binarizing(im, 200)  # 图片二值化    # im.show()    im = im.point(lambda x: 0 if x < 200 else 256)    im = denoising(im)  # 图片去噪    # im.save(f_name)    # im.show()    # # im.save('test.clear.jpg','jpeg')    # im.show()    # 自定义灰度界限，大于这个值为黑色，小于这个值为白色    # threshold = 200    # table = []    # for i in range(256):    #     if i < threshold:    #         table.append(0)    #     else:    #          table.append(1)    #    # # 图片二值化    # im = im.point(table, '1')    # im.show()    # 测试数据    #    # im = im.convert('L')  # 灰度图转换    # im = PIL.ImageOps.invert(im)    # im.save(f_name)    if im.mode == 'RGBA':        r, g, b, a = im.split()        rgb_image = Image.merge('RGB', (r, g, b))        inverted_image = PIL.ImageOps.invert(rgb_image)        r2, g2, b2 = inverted_image.split()        final_transparent_image = Image.merge('RGBA', (r2, g2, b2, a))        final_transparent_image.save(f_name)    else:        inverted_image = PIL.ImageOps.invert(im)        inverted_image.save(f_name)    # im.show()    #    # img = cv2.imread(f_name, 1)    # # cv2.imshow('img', img)    # img_shape = img.shape  # 图像大小(565, 650, 3)    # print(img_shape)    # h = img_shape[0]    # w = img_shape[1]    # # 彩色图像转换为灰度图像（3通道变为1通道）    # gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    # print(gray.shape)    # # 最大图像灰度值减去原图像，即可得到反转的图像    # dst = 255 - gray    # cv2.imshow('dst', dst)    # cv2.waitKey(0)    return Image.open(f_name)